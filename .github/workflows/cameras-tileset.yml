name: Build & Publish Cameras Tileset

on:
  workflow_dispatch: {}     # run manually for the first success

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-node@v4
        with:
          node-version: "20"

                        # 0) Fetch: your script writes state files to public/usa/*.json
      - name: Fetch latest Flock cameras (per-state files)
        run: |
          set -e
          mkdir -p public/usa data
          node fetch-alprs.js
          echo "Index written (from your script):"
          ls -lh public/index.json || true
          echo "Sample state files:"
          ls -lh public/usa | head -n 10 || true

      # 0.1) Combine all state files -> ONE raw GeoJSON used by the rest of the pipeline
      - name: Combine state files -> data/raw_deflock.geojson
        run: |
          node - <<'NODE'
          const fs = require('fs');
          const path = require('path');
          const dir = 'public/usa';
          let features = [];
          if (!fs.existsSync(dir)) {
            console.error('Directory not found:', dir);
            process.exit(1);
          }
          for (const fname of fs.readdirSync(dir)) {
            if (!fname.endsWith('.json')) continue;
            const fpath = path.join(dir, fname);
            const text = fs.readFileSync(fpath, 'utf8').trim();
            if (!text) continue;
            let j;
            try { j = JSON.parse(text); } catch { continue; }

            // Accept FeatureCollection, array of features/records, or other common shapes
            let arr = Array.isArray(j) ? j : (j.features || j.records || j.data || j.items || []);
            if (!Array.isArray(arr)) continue;

            for (const item of arr) {
              // Prefer proper GeoJSON Point
              const g = item?.geometry;
              if (g?.type === 'Point' && Array.isArray(g.coordinates) && g.coordinates.length >= 2) {
                features.push({
                  type: 'Feature',
                  geometry: { type: 'Point', coordinates: g.coordinates.slice(0,2) },
                  properties: item.properties || {}
                });
                continue;
              }
              // Otherwise try to build from properties with lat/lon-like keys
              const p = (item && typeof item === 'object') ? (item.properties || item) : {};
              const n = v => (Number.isFinite(Number(v)) ? Number(v) : null);
              let lng = n(p.lng ?? p.lon ?? p.long ?? p.longitude ?? p.x);
              let lat = n(p.lat ?? p.latitude ?? p.y);
              if (lng !== null && lat !== null) {
                features.push({
                  type: 'Feature',
                  geometry: { type: 'Point', coordinates: [lng, lat] },
                  properties: p
                });
              }
            }
          }
          fs.mkdirSync('data', { recursive: true });
          fs.writeFileSync('data/raw_deflock.geojson', JSON.stringify({ type:'FeatureCollection', features }));
          console.log('COMBINED raw features:', features.length);
          NODE

      # 0.2) Guard: RAW must parse and have many records
      - name: Check RAW count
        run: |
          node - <<'NODE'
          const fs=require('fs');
          const t=fs.readFileSync('data/raw_deflock.geojson','utf8').trim();
          if(!t.length) throw new Error('raw_deflock.geojson is empty');
          let j=null, n=0;
          try { j=JSON.parse(t); } catch {}
          if (Array.isArray(j)) n=j.length;
          else if (j && (j.features||j.records||j.data||j.items)) {
            const arr = j.features||j.records||j.data||j.items;
            if (Array.isArray(arr)) n=arr.length;
          }
          console.log('RAW records:', n);
          if (n < 10) throw new Error('Too few RAW records; aborting');
          NODE

      # 1) Transform -> data/cameras.geojson
      - name: Transform -> cameras.geojson
        run: |
          set -e
          node scripts/transform_cameras.mjs
          ls -lh data/cameras.geojson
          node -e "const fs=require('fs');const g=JSON.parse(fs.readFileSync('data/cameras.geojson','utf8'));const f=g.features||[];console.log('TRANSFORMED features:',f.length);console.log('FIRST coords:',(f[0]||{}).geometry?.coordinates); if(f.length<10) throw new Error('Too few transformed features; aborting')"

      # (optional) keep files to inspect from the run page
      - name: Upload raw & transformed artifacts
        uses: actions/upload-artifact@v4
        with:
          name: cameras-debug
          path: |
            data/raw_deflock.geojson
            data/cameras.geojson

      # 2) Install Mapbox tilesets CLI
      - name: Install Mapbox tilesets CLI
        run: python3 -m pip install --upgrade pip mapbox-tilesets

      # 3) Upload/replace the tileset source
      - name: Upload tileset source
        env:
          MAPBOX_ACCESS_TOKEN: ${{ secrets.MAPBOX_SECRET_TOKEN }}
        run: |
          test -s data/cameras.geojson || (echo "cameras.geojson is empty" && exit 1)
          tilesets upload-source masonzbirkett cameras_src data/cameras.geojson --replace

      # 4) Create the tileset (FIRST RUN ONLY)
      - name: Create tileset (one-time)
        env:
          MAPBOX_ACCESS_TOKEN: ${{ secrets.MAPBOX_SECRET_TOKEN }}
        run: |
          tilesets create masonzbirkett.cameras --recipe tilesets/cameras.recipe.json --name "Flock Cameras"

      # 5) Publish (build) the tileset
      - name: Publish tileset
        env:
          MAPBOX_ACCESS_TOKEN: ${{ secrets.MAPBOX_SECRET_TOKEN }}
        run: |
          tilesets publish masonzbirkett.cameras



